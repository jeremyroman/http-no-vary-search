{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-15T00:37:21.668985+00:00",
  "repo": "jeremyroman/http-no-vary-search",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOLx27pM6R4L5l",
      "title": "WHATWG list notation \u00ab \u00bb is unfamiliar to some readers",
      "url": "https://github.com/jeremyroman/http-no-vary-search/issues/4",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft includes this text in an example:\r\n\r\n>  \u00ab \"\u00e9 \u6c17\" \u00bb\r\n\r\nThat's two layers of quoting.  One layer is probably enough.",
      "createdAt": "2024-08-05T01:40:06Z",
      "updatedAt": "2024-08-08T13:57:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jeremyroman",
          "authorAssociation": "OWNER",
          "body": "This isn't actually two layers of quoting, though it may be an artifact of WHATWG convention (namely, the [list literal shorthand](https://infra.spec.whatwg.org/#lists)), i.e., the variance has exactly one vary param, which is the string \"\u00e9 \u6c17\".\r\n\r\nIf this notation is unfamiliar to readers of IETF documents, it could be called out more explicitly in _Conventions and Definitions_ (which does link to the WHATWG infra document) or changed to some other notation.",
          "createdAt": "2024-08-07T18:17:40Z",
          "updatedAt": "2024-08-07T18:17:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "That's a list?  Wow, that wasn't obvious.  I've seen `[]` or `()` used in other contexts with considerable success.",
          "createdAt": "2024-08-08T00:02:11Z",
          "updatedAt": "2024-08-08T00:02:11Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOLx27pM6R4MI6",
      "title": "Add an introduction",
      "url": "https://github.com/jeremyroman/http-no-vary-search/issues/5",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft doesn't bother with any of the usual frippery that is in other similar documents, like establishing what the problem is, why it is important to solve, and providing an overview of the solution.  That's going to be challenging.",
      "createdAt": "2024-08-05T01:41:18Z",
      "updatedAt": "2024-08-05T01:41:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOLx27pM6R4M12",
      "title": "Extensibility, not",
      "url": "https://github.com/jeremyroman/http-no-vary-search/issues/6",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> The dictionary must only contain entries whose keys are one of key-order, params, except.\r\n\r\nIf this is a MUST (is it?) then this will make it impossible to extend the field semantics.  An analysis of why this is acceptable is probably wise.\r\n\r\nNote: I don't think that you need to establish an IANA registry for keys or anything like that.  This is a self-contained proposal that doesn't _need_ extensibility to function.  However, it would be good to establish clear rules for what an implementation does when an extension is present.  Right now, it seems to be that it completely disables the special logic that this draft introduces.  That seems wrong to me.  It would be more robust to ignore keys that are not supported.",
      "createdAt": "2024-08-05T01:44:51Z",
      "updatedAt": "2024-08-19T06:26:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jeremyroman",
          "authorAssociation": "OWNER",
          "body": "/cc @domenic (who wrote this precise wording)\r\n\r\n> If this is a MUST (is it?) then this will make it impossible to extend the field semantics. An analysis of why this is acceptable is probably wise.\r\n\r\nI'm not personally very familiar with how (in IETF) authoring conformance requirements bind future versions of a specification, or other documents, to extend it. The intent here, as I understand it, is simply to declare to authors that this document does not define the behavior of any field values which include other keys -- and an author using additional keys would need to be in conformance with some other, newer, document.\r\n\r\n> Right now, it seems to be that it completely disables the special logic that this draft introduces. That seems wrong to me. It would be more robust to ignore keys that are not supported.\r\n\r\nI'm not certain that is the case, but am open to discussing. It seems to me that future extensions might:\r\n\r\n1. Make two responses match, which previously did not. (e.g., a new `key-ascii-case` token, which treated query param keys as case-insensitive)\r\n2. Make two responses not match, which previous did. (e.g., a new `respect-exact-values` token, which required values for query params not ignored to match byte-wise, and not treat `+` and `%20`, or `a` and `%41`, as equivalent)\r\n3. Some combination of the previous two.\r\n\r\nFor extensions of the first type, I agree, ignoring unrecognized keys is more robust in that it lets authors get as close to the intended meaning as possible within the client's support.\r\n\r\nFor extensions of the second or third type, though, ignoring unrecognized keys could result in a cache producing an erroneous cache hit \u2013 and a user seeing an incorrect resource.\r\n\r\nSince the key is by definition unknown at the time this specification is written, even if most extensions would be of the first type it seems safer to assume that some extensions might be of the second or third type, and the risk of incorrect cache behavior might make such an extension dangerous to adopt if unrecognized parameters are ignored by earlier clients.\r\n\r\nThere might be ways to sidestep this, like some way of marking which extension parameters should be ignored if unknown, or giving HTTP some better feature detection mechanism (but that's an enormous challenge considering the presence of proxies and caches), but none seem an obvious win to me.",
          "createdAt": "2024-08-07T20:51:29Z",
          "updatedAt": "2024-08-07T20:51:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "That seems like a good analysis.  My conjecture (take that for what it is), is that having any extension be *more* greedy (matching more URLs) is the most useful path to take.  Your case-folding example seems like it is more reasonable than any attempt to tighten up.\r\n\r\nIs it possible for the other case to specify a backward-compatible exact-matching.  Maybe by using `params` in the least permissive mode, with a parallel `exact-params` parameter?",
          "createdAt": "2024-08-08T00:01:16Z",
          "updatedAt": "2024-08-08T00:01:16Z"
        },
        {
          "author": "domenic",
          "authorAssociation": "NONE",
          "body": "I'm not sure I understand the concern here. If we add new options, we'll publish a new specification that will supersede this one, and conformance with the old one won't matter.",
          "createdAt": "2024-08-08T01:23:52Z",
          "updatedAt": "2024-08-08T01:23:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "@domenic, what you specify here will determine to a large extent what options you have when defining the new specification.  It pays to think about what might happen at that time.  Defining new parameters is clearly one of the possible paths available, but the present specification effectively causes the field to be ignored if a client receives a parameter they don't understand.  That's safe, but does it create the set up the right conditions for evolving the specification later? ",
          "createdAt": "2024-08-08T04:05:25Z",
          "updatedAt": "2024-08-08T04:05:25Z"
        },
        {
          "author": "jeremyroman",
          "authorAssociation": "OWNER",
          "body": "(I'm assuming that how the specification directs implementations to behave on unknown input matters here more than the author conformance requirements.)\r\n\r\nIs there particular good/bad experiences with past HTTP header fields that should guide us here? At the moment it seems we're basically up to abstract conjecture.\r\n\r\nI agree that ignoring unrecognized things (details TBD) makes it easier to roll out use of extensions in the future, at the cost of constraining those extensions (unless we add complexity to mitigate that), and that we could probably make that change safely at this point if everyone agreed (what is the best process for that?) this was a worthwhile tradeoff to make.",
          "createdAt": "2024-08-16T19:52:47Z",
          "updatedAt": "2024-08-16T19:52:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "A good number of fields already work the same way, with considerable success.  Offhand, that includes Cache-Control, Content-Security-Policy, and Permissions-Policy.",
          "createdAt": "2024-08-19T06:26:30Z",
          "updatedAt": "2024-08-19T06:26:30Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOLx27pM6R4Odc",
      "title": "Is the default equivalent to an empty field?",
      "url": "https://github.com/jeremyroman/http-no-vary-search/issues/7",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The definition for the default says:\r\n\r\n>  The default URL search variance is a URL search variance whose no-vary params is an empty list, vary params is wildcard, and vary on key order is true.\r\n\r\nThis is something that can be explicitly specified.  Indeed, the processing returns the default if the field is specified but empty.\r\n\r\nBut specifying the field indicates an understanding of the advanced matching algorithm, which might imply that the caller wishes to engage the algorithm.  That would mean that `https://example.com/?q&&&&` is equivalent to `https://example.com/?q&&`, where it wouldn't be otherwise.\r\n\r\nIs it useful to distinguish an expression that engages the algorithm vs. one that does not?  Yes, the answer could be \"we fall back to default processing, which is safe\", but it seems like that's a logic error and somewhat surprising.",
      "createdAt": "2024-08-05T01:52:33Z",
      "updatedAt": "2024-08-07T20:22:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jeremyroman",
          "authorAssociation": "OWNER",
          "body": "/cc @domenic @liviutinta\r\n\r\n> This is something that can be explicitly specified. Indeed, the processing returns the default if the field is specified but empty.\r\n\r\nYes, it can be explicitly specified. I'm not sure whether all HTTP implementations would permit an empty field ([RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2) disavows them for the most part afaict), but values such as `key-order=?0` or `params=()` would do the trick.\r\n\r\n> But specifying the field indicates an understanding of the advanced matching algorithm, which might imply that the caller wishes to engage the algorithm. That would mean that https://example.com/?q&&&& is equivalent to https://example.com/?q&&, where it wouldn't be otherwise.\r\n\r\nAs currently written, there is no way of getting _just_ the decoding-related behavior (like spurious ampersands and the `+` vs `%20` distinction), though you could get close by varying only on a nonsense parameter (`No-Vary-Search: params=(\"__iamneverspecifiedintherealworld\")`). If anyone wanted this, we could add a way of expressing it (and suppressing this revert-to-default logic), such as `No-Vary-Search: encoding-only`.\r\n\r\n> Is it useful to distinguish an expression that engages the algorithm vs. one that does not? Yes, the answer could be \"we fall back to default processing, which is safe\", but it seems like that's a logic error and somewhat surprising.\r\n\r\nI'm not sure what it means to be a logic error here. My current thinking is that the value of such cases is unclear but there is risk of confusion arising from an empty and absent header having different meanings (or a facially meaningless value having a different meaning from an absent one).\r\n\r\nIt seems to me that an accidental cache miss is much better than an accidental cache hit (as you note, it's safe), so if we're going to have a single such behavior, the current, exact matching logic is the better fallback even if it compromises conceptual purity a little.",
          "createdAt": "2024-08-07T20:22:33Z",
          "updatedAt": "2024-08-07T20:22:33Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOLx27pM5toAxh",
      "title": "Reformat text from the WICG draft and as kramdown-rfc compatible markdown",
      "url": "https://github.com/jeremyroman/http-no-vary-search/pull/1",
      "state": "MERGED",
      "author": "jeremyroman",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The text is mostly preserved verbatim, though since auto-linking in kramdown-rfc is much more limited, not all references (especially to WHATWG Infra) are linked. The term \"list\" is replaced with \"array\" (as in RFC 8941) only in contexts where it is applied directly to the result of RFC 8941, which uses the term \"list\" to refer to a specific kind of structured field value which is not meant here (and it may be confusing which is meant, even with the remarks about WHATWG notation and conventions).\r\n\r\nSome formatting is also lost due to the constraints of the Markdown -> HTML -> RFC XML -> {HTML, TXT} pipeline used for modern Internet-Draft processing.\r\n\r\nNo additional text is yet added, e.g., related to integration with RFC 9111 (HTTP-CACHING) or IANA registration.",
      "createdAt": "2024-04-24T16:29:08Z",
      "updatedAt": "2024-04-24T16:30:49Z",
      "baseRepository": "jeremyroman/http-no-vary-search",
      "baseRefName": "main",
      "baseRefOid": "5b451abf747f14d725eac7f15d36778ff833a638",
      "headRepository": "jeremyroman/http-no-vary-search",
      "headRefName": "import-wicg",
      "headRefOid": "e957c0bc5a34bfc9ae54d0936b23e61a958495ff",
      "closedAt": "2024-04-24T16:30:48Z",
      "mergedAt": "2024-04-24T16:30:48Z",
      "mergedBy": "jeremyroman",
      "mergeCommit": {
        "oid": "b727efd65c6ad29528369511724f0849dd31d51d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOLx27pM5tvJW7",
      "title": "Correct an example",
      "url": "https://github.com/jeremyroman/http-no-vary-search/pull/2",
      "state": "MERGED",
      "author": "jeremyroman",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This example did not get copied correctly the first time.",
      "createdAt": "2024-04-25T14:46:15Z",
      "updatedAt": "2024-04-25T14:46:37Z",
      "baseRepository": "jeremyroman/http-no-vary-search",
      "baseRefName": "main",
      "baseRefOid": "b727efd65c6ad29528369511724f0849dd31d51d",
      "headRepository": "jeremyroman/http-no-vary-search",
      "headRefName": "correct-example",
      "headRefOid": "61e21296da4cf04c7f7f08ec5d4e2c03ae99e009",
      "closedAt": "2024-04-25T14:46:34Z",
      "mergedAt": "2024-04-25T14:46:34Z",
      "mergedBy": "jeremyroman",
      "mergeCommit": {
        "oid": "ba6601abb198c0bcd758a9386d148c9fa09c0e7d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "PR_kwDOLx27pM5xdp2q",
      "title": "Replicate updated security & privacy considerations to IETF draft.",
      "url": "https://github.com/jeremyroman/http-no-vary-search/pull/3",
      "state": "MERGED",
      "author": "jeremyroman",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This was updated in the upstream WICG document: https://github.com/WICG/nav-speculation/commit/29cfa18ac33d299ee93032e0cd2be085e9608257",
      "createdAt": "2024-06-04T19:13:37Z",
      "updatedAt": "2024-06-04T19:13:58Z",
      "baseRepository": "jeremyroman/http-no-vary-search",
      "baseRefName": "main",
      "baseRefOid": "ba6601abb198c0bcd758a9386d148c9fa09c0e7d",
      "headRepository": "jeremyroman/http-no-vary-search",
      "headRefName": "replicate-sec-priv",
      "headRefOid": "fec10a16ba2b10324ab4e7fa1e971ae8122d3a84",
      "closedAt": "2024-06-04T19:13:53Z",
      "mergedAt": "2024-06-04T19:13:53Z",
      "mergedBy": "jeremyroman",
      "mergeCommit": {
        "oid": "d6c5beac723e9416ca3c7fdd1313b668d3d1bf01"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOLx27pM55ueD8",
      "title": "Ignore unrecognized dictionary keys",
      "url": "https://github.com/jeremyroman/http-no-vary-search/pull/8",
      "state": "MERGED",
      "author": "jeremyroman",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Addresses #6.",
      "createdAt": "2024-08-28T15:20:26Z",
      "updatedAt": "2024-09-06T18:13:09Z",
      "baseRepository": "jeremyroman/http-no-vary-search",
      "baseRefName": "main",
      "baseRefOid": "d6c5beac723e9416ca3c7fdd1313b668d3d1bf01",
      "headRepository": "jeremyroman/http-no-vary-search",
      "headRefName": "nvs-ignore-unrecognized-keys",
      "headRefOid": "20430896887344d5231b7b8ac8a6459481eab68a",
      "closedAt": "2024-09-06T18:13:09Z",
      "mergedAt": "2024-09-06T18:13:09Z",
      "mergedBy": "jeremyroman",
      "mergeCommit": {
        "oid": "da1986358a94b4321d8bb56bbe1cee67f5e423c5"
      },
      "comments": [
        {
          "author": "jeremyroman",
          "authorAssociation": "OWNER",
          "body": "@domenic @martinthomson wdyt?\r\n\r\nI think I'm okay with loosening this slightly. Even though it restricts some forms of extensibility, as Martin points out it may make it easier to deploy the more likely ways for this spec to be extended.\r\n\r\nIf this looks good, I'll backport the text to the WICG repository as well. I also have a [Chromium CL](https://chromium-review.googlesource.com/c/chromium/src/+/5800476) to apply the change to Chrome. I'm pretty sure this will be safe with current usage, but I have a histogram to detect existing usage of unrecognized keys so we can investigate if it turns out to be happening in the wild already.",
          "createdAt": "2024-08-28T15:29:30Z",
          "updatedAt": "2024-08-28T15:29:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLx27pM6HIOKc",
          "commit": {
            "abbreviatedOid": "5f70b0d"
          },
          "author": "domenic",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-28T19:19:42Z",
          "updatedAt": "2024-08-28T19:19:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOLx27pM6HKR1i",
          "commit": {
            "abbreviatedOid": "5f70b0d"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T03:40:38Z",
          "updatedAt": "2024-08-29T03:40:42Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This is helpful as far as framing goes, but it is a bit of a forward-looking statement.\r\n\r\nThe pattern I've seen more often is \"Search variance MAY contain parameters other than those listed in this specification.  A recipient MUST ignore any parameter that it does not understand.\"",
              "createdAt": "2024-08-29T03:40:38Z",
              "updatedAt": "2024-08-29T03:40:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLx27pM6ITt7D",
          "commit": {
            "abbreviatedOid": "5f70b0d"
          },
          "author": "jeremyroman",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-06T17:55:15Z",
          "updatedAt": "2024-09-06T17:55:15Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I guess where I struggle is that a strict reading of that would imply that senders can add their own arbitrary data to the header, confident that it will be ignored by recipients -- but in fact in the future those values may become meaningful, so it's unwise for authors to do so.\r\n\r\nTried again to compromise by removing it from the list of authoring requirements proper, but preserving a note that other keys are scary to use.",
              "createdAt": "2024-09-06T17:55:15Z",
              "updatedAt": "2024-09-06T17:55:15Z"
            }
          ]
        }
      ]
    }
  ]
}